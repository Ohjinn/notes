- [5.1 트랜잭션과 잠금](#51-트랜잭션과-잠금)
  - [트랜잭션](#트랜잭션)
    - [MySQL에서의 트랜잭션](#mysql에서의-트랜잭션)
- [5.2 MySQL 엔진의 잠금](#52-mysql-엔진의-잠금)
    - [글로벌 락](#글로벌-락)
    - [테이블 락](#테이블-락)
    - [네임드 락](#네임드-락)
    - [메타 데이터 락](#메타-데이터-락)
- [5.3 InnoDB 스토리지 엔진 잠금](#53-innodb-스토리지-엔진-잠금)
    - [레코드 락](#레코드-락)
    - [갭 락](#갭-락)
    - [넥스트 키 락](#넥스트-키-락)
    - [자동 증가 락](#자동-증가-락)
- [5.4 MySQL의 격리 수준](#54-mysql의-격리-수준)
  - [READ\_UNCOMMITTED](#read_uncommitted)
  - [READ\_COMMITTED](#read_committed)
  - [REPEATABLE\_READ](#repeatable_read)
  - [SERIALIZABLE](#serializable)


# 5.1 트랜잭션과 잠금
MySQL의 동시성에 영향을 미치는 잠금, 트랜잭션, 트랜잭션의 격리 수준에 대한 장이다.

## 트랜잭션
MyISAM, MEMORY같은 스토리지 엔진은 트랜잭션을 지원하지 않는다. 이번 장의 내용은 InnoDB가 주가 된다.

### MySQL에서의 트랜잭션
트랜잭션은 논리적인 작업 셋 자치가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장해준다.  
MySQL 스토리지 엔진 중에는 InnoDB만 트랜잭션을 지원해준다.

데이터 커넥션의 범위와 트랜잭션의 범위는 최소화해야 한다. 문제가 많은 예로 살펴보면  

```markdown
1. 처리 시작
   - 데이터베이스 커넥션 생성(또는 커넥션 풀에서 가져오기)
   - 트랜잭션 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
9. 알림 메일 발송 이력을 DBMS에 저장
    - 트랜잭션 종료(COMMIT)
    - 데이터베이스 커넥션 반납
10. 처리 완료
```

- 실제로 DBMS에 데이터를 저장하는 작업은 5번부터 시작된다.
   - 데이터베이스 커넥션은 개수가 제한적이라 각 단위 프로그램의 커넥션 소유 시간이 길어질수록 여유 커넥션이 줄어든다.
- 8번 메일 전송, FTP파일 전송, 원격통신 등은 트랜잭션 내에서 제거해야 한다.
  - 메일 서버와 통신할 수 없다면 웹 서버뿐 아니라 DBMS 서버까지 위험해진다.
- 하나의 트랜잭션으로 묶을 필요가 없다.
  - 5, 6번은 하나의 트랜잭션으로 묶어야 한다.
  - 7번은 데이터의 단순 확인 및 조회로 트랜잭션에 포함하지 않아도 된다.
  - 9번은 성격이 다르기 때문에 별도의 트랜잭션으로 분리하는 것이 좋다.

```markdown
1. 처리 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
   - 데이터베이스 커넥션 생성(또는 커넥션 풀에서 가져오기)
   - 트랜잭션 시작
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
    - 트랜잭션 종료(COMMIT)
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
   - 트랜잭션 시작
9. 알림 메일 발송 이력을 DBMS에 저장
    - 트랜잭션 종료(COMMIT)
    - 데이터베이스 커넥션 반납(또는 커넥션 풀에 반납)
10. 처리 완료
```

이렇게 하면 DBMS의 부하를 낮출 수 있다.


# 5.2 MySQL 엔진의 잠금
MySQL의 잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나뉜다.

MySQL 엔진에서는
- 글로벌 락
- 테이블 락: 테이블 데이터 동기화를 위한 락
- 메타데이터 락: 테이블의 구조를 잠그는 락
- 네임드 락: 사용자의 필요에 맞게 사용할 수 있는 락

등의 락들이 있고 하나씩 이야기해보자.

### 글로벌 락
- MySQL에서 제공하는 락 가운데 가장 범위가 크다.
- FLUSH TABLES WITH READ LOCK 명령으로 획득할 수 있다.
- SELECT를 제외한 DDL, DML 문장의 실행은 MySQL 서버 전체에서 락이 해제될때까지 대기 상태로 남는다.

READ LOCK
- 락을 가지고 있는 세션이 테이블을 읽을 수 있다(하지만 쓰지는 못한다.)
- 여러 세션이 동시에 테이블에 대한 READ LOCK을 획득할 수 있다.
- 다른 세션들은 명시적으로 READ LOCK 없이 테이블을 읽을 수 있다.

WRITE LOCK
- 락을 가지고 있는 세션이 읽고 쓸 수 있다.
- 락을 가지고 있는 세션만 테이블에 접근할 수 있고 다른 세션은 접근 불가능하다.

```
FLUSH TABLES WITH READ LOCK이 실행되기 전에 테이블이나 레코드에 쓰기 잠금이 실행됐다면
해당 테이블의 읽기 잠금을 걸기 위해 먼저 실행된 SQL과 트랜잭션이 완료될 때까지 기다려야 한다.
장시간 실행되는 쿼리와 FLUSH TABLES WITH READ LOCK이 최악의 케이스로 실행되면 MySQL 서버의
모든 테이블에 대한 INSERT, UPDATE, DELETE 쿼리의 실행이 오랫동안 실행되지 못할수도 있다.
따라서, 가급적 사용하지 않는 것이 좋다.
```

하지만 8.0부터는 InnoDB가 기본 스토리지 엔진으로 채택됐고 InnoDB는 트랜잭션을 지원하기 때문에 일관된  
데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요가 없어졌기에 조금 더 가벼운 글로벌 락 Xtrabackup이나 Enterprise Backup같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됐다.

```
LOCK INSTANCE FOR BACKUP;
-- 백업
UNLOCK INSTANCE;
```

특정 세션에서 백업 락을 획득하면 모든 세션에서 테이블의 스키나마 사용자의 인증 관련 정보를 변경할 수 없다.
- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
- REPAIR TABLE과 OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경

백업 락은 일반적인 테이블의 데이터 변경은 허용된다. 
MySQL 서버 구성은 소스 서버와 레플리카 서버로 구성되는데 백업은 주로 레플리카 서버에서 실행된다. 
백업이 FLUSH TABLES WITH READ LOCK 명령을 통해 글로벌 락을 획득하면 복제는 백업 시간만큼 지연될 수밖에 없다.  
Xtrabackup이나 Enterprise Backup 툴들은 복제 진행 상태에서도 일관된 백업을 만들 수 있지만 실행 도중 스키마 변경이 일어나면 백업이 실패하고 시간을 들여 다시 백업을 실행해야 한다. 이를 막기 위해 백업 락이 생겼다.

### 테이블 락

### 네임드 락

### 메타 데이터 락

# 5.3 InnoDB 스토리지 엔진 잠금

### 레코드 락

### 갭 락

### 넥스트 키 락

### 자동 증가 락

# 5.4 MySQL의 격리 수준

## READ_UNCOMMITTED

## READ_COMMITTED

## REPEATABLE_READ

## SERIALIZABLE